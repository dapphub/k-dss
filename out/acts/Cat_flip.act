behaviour flip of Cat
interface flip(uint256 n, uint256 wad)

types

    Ilk   : bytes32
    Urn   : address
    Ink   : uint256
    Tab   : uint256
    Flip  : address Flippy
    Chop  : uint256
    Lump  : uint256
    Vow   : address
    Ttl   : uint48
    Tau   : uint48
    Kicks : uint256
    Live  : uint256

storage

    #Cat.flips[n].ilk   |-> Ilk
    #Cat.flips[n].urn   |-> Urn
    #Cat.flips[n].ink   |-> Ink => Ink - (Ink * wad) / Tab
    #Cat.flips[n].tab   |-> Tab => Tab - wad
    #Cat.ilks[ilk].flip |-> Flip
    #Cat.ilks[ilk].chop |-> Chop
    #Cat.ilks[ilk].lump |-> Lump
    #Cat.vow            |-> Vow
    #Cat.live           |-> Live

storage Flip

    #Flipper.ttl_tau                     |-> #WordPackUInt48UInt48(Ttl, Tau)
    #Flipper.kicks                       |-> Kicks => 1 + Kicks
    #Flipper.bids[1 + Kicks].bid         |-> _ => 0
    #Flipper.bids[1 + Kicks].lot         |-> _ => (Ink * wad) / Tab
    #Flipper.bids[1 + Kicks].guy_tic_end |-> _ => #WordPackAddrUInt48UInt48(ACCT_ID, 0, TIME + Tau)
    #Flipper.bids[1 + Kicks].urn         |-> _ => Urn
    #Flipper.bids[1 + Kicks].gal         |-> _ => Vow
    #Flipper.bids[1 + Kicks].tab         |-> _ => (wad * Chop) /Int 1000000000000000000000000000)

iff

    Live == 1
    wad <= Tab
    (wad == Lump) or ((wad < Lump) and (wad == Tab))
    VCallDepth < 1023

iff in range uint256

    Ink * wad
    wad * Chop

if

    VGas > 300000

returns 1 + Kicks
